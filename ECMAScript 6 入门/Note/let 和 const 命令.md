# let 和 const 命令

## 一、let 命令

### 1、let 的特点

- **只在声明的代码块生效**

	```javascript
	{
		let a = 2;
	}
	
	console.log(a);    // 报错
	```
	
- **不存在变量提升**：变量必须在声明之后才能使用，否则会报错；

- **暂时性死区**：在块级作用域内，使用 let 命令声明的变量，该变量就绑定了该作用域，形成一个封闭的作用域，这时如果在未声明变量前使用该变量，就会报错；也就是说，变量未声明时，是不能使用该变量的，把这种现象称为 “暂时性死区”。

- **不允许重复**：在相同作用域内，不允许声明相同的变量；

- **块级作用域**：内部作用域可以访问外部作用域的变量，但是外部作用域无法访问内部作用域的变量。

```javascript
// 报错：在相同作用域内声明相同变量
function test() {
	let a = 8;
	var a = 9;
}

// 不会报错：因为 arg 处于不同作用域
function test(arg) {
	{
		let arg = 8;
	}
}
```

```javascript
var test = 8;
if (true) {
	console.log(test);    // 报错
	let test = 9;
}
```
	
### 2、let 应用场景

- for 循环计数器很适合使用 let 命令；

	```javascript
	var b = [];
	for (let i = 0; i < 10; i++) {
		b[i] = function() {
			console.log('Function: ' + i);
    	};
    	console.log(b[i]);
	}
	b[6]();    // 6（如果上述 i 使用 var 声明的话，那么输出的结果则为 10）
	```
	
## 二、const 命令

### 1、const 特点

- 声明只读常量，一旦声明之后，其值是不能修改的；

- 声明变量时，必须初始化，否则会报错；

- 只在所声明的块级作用域内有效；

- 不存在变量提升；

- 暂时性死区；

- 不允许重复。

### 2、本质

`const` 命令声明的变量的值不变，是指其变量所指向的内存地址保存的值是不变的，这对于基本数据类型（字符串、整型）来说是生效的；但是对于复合类型（数组和对象）来说就有区别了，比如一个变量保存一个对象，此时该变量是存储在栈中，保存的是对象的内存地址，而对象的数据结构是存储在堆中，也就是说，变量指向的是对象在堆中的内存地址，对于 `const` 命令来说，不变的是其内存地址，至于对象的数据结构变或者不变，`const` 就无法控制了。

如果想让对象及对象的属性不变，可以将对象**冻结**，及采用方法 `Object.freeze(obj)`
	
## 三、ES6 规定要点

- ES6 明确规定，如果区块中存在 `let` 和 `const` 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

- ES6 规定，块级作用域之中，函数声明语句的行为类似于 `let`，在块级作用域之外不可引用。

- var 命令和 function 命令声明的全局变量，依然属于顶层对象 `window`（这里的环境是指浏览器）的属性，兼容 ES5；而使用 let 和 const 命令声明的全局变量，不再属于顶层对象 `window` 的属性，即在 ES6 中，顶层对象的属性与全局变量脱钩。
	
## 四、注意点

- for 循环包含两个独立的作用域，循环变量包含的部分是一个**父作用域**，而循环体内包含的部分是一个**子作用域**。因此，即使循环变量和循环体内声明的变量的名字是相同，但是其实它们是处在两个独立的作用域内，互不影响。

- 不同环境顶层对象不一样，表现在：

	- 浏览器的顶层对象指向的是 `window`、`self`；

	- Web Worker 的顶层对象指向的是 `self`；

	- Node 的顶层对象指向的是 `global`。

## 五、ES6 声明变量的六种方法

- var

- function

- let

- const

- import

- class