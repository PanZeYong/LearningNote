# 函数的扩展

## 一、函数参数的默认值

### 1、基本用法

ES6 允许为函数的参数指定默认值，即直接写在参数定义的后面。

```javascript
function default (x, y = 'hello') {
	console.log(x, y);
}
```

需要注意的点： 

- 参数变量是默认声明的，因此不能使用 `let` 或者 `const` 再次声明。

- 使用参数默认值时，函数不能有同名参数。

- 参数默认值是惰性求值的。（默认值是表达式求值）。

- 将参数默认值指定为 `undefined`，表示该参数可以省略。

### 2、对象的解构赋值与函数参数的默认值

对象的解构赋值例子：

```javascript
function foo({x, y = 5}) {
  console.log(x, y);
}

foo() // 报错
```

函数 foo 的参数是一个对象，需要传递对象才能对 `x` 和 `y` 变量解析；如果不传的参数，那么则会报错。

函数参数指定默认值例子：

```javascript
function foo({x, y = 5} = {}) {
  console.log(x, y);
}
```

### 3、参数默认值的位置

通常情况下，指定函数参数的默认值，应该是函数参数的最后一个。

### 4、函数的 length 属性

`length` 属性的定义是预期函数传入参数的个数，如果我们指定了函数参数的默认值，那么该参数就不属于预期参数，不能计算进去。即函数 `length` 属性的值等于函数参数的个数减去指定默认值参数的个数。

需要注意的点：

- `rest` 参数不会计入 `length` 属性；

- 如果指定默认值的参数不是尾参数，那么 `length ` 属性的值等于指定默认值参数之前参数的个数。

### 5、作用域

当函数参数指定默认值时，函数进行声明初始化时，参数会形成一个单独的作用域；直到初始化结束后，作用域才会消失。

## 二、rest（...test）

用于获取函数多余的参数，并将参数存放于数组。`rest` 参数可以替代 `arguments`，因为 `arguments` 是一个类数组的对象，需要使用 `Array.prototype.slice.call()` 方法将其转为真正的数组；而 `rest` 参数本身是真正的数组，使用起来很方便。

`rest` 参数必须是函数参数列表中的最后一个参数，否则使用起来会报错。

## 三、严格模式

ES6 规定：只要函数使用了**默认值**、**解构赋值**或者**扩展运算符**，函数内部就不能显示设定为严格模式；否则使用起来会报错。

### 规避这种限制的两种方法：

- 设定全局的严格模式；

- 把函数包含在一个无参数的立即执行函数里面。（IIF）

## 四、name 属性

函数 `name` 属性，返回函数的名称。但是在 ES6 和 ES5 稍微有点区别，具体表现在：

- 如果将一个匿名函数赋值给变量，那么在 ES5 中 `name` 属性会返回**空字符串**；而 ES6 则会返回实际的函数名称。

- 如果将一个有具体名称的函数赋值给一个变量，那么在 ES5 和 ES6 中，`name` 属性返回的值是一样，都是具体的函数名字。

## 五、箭头函数

### 1、基本用法

ES6 允许使用 “箭头”（`=>`）定义函数，称为箭头函数。

```javascript
var foo = x => x;

等同于
var foo = function (x) {
	return x;
}

// foo(5)
```

使用时需要注意的点：

- 如果箭头函数不需要参数或者需要多个参数，可以使用**圆括号**代表参数一部分。

- 如果箭头函数的代码块语句多于一行代码的话，则需要使用大括号将代码块括起来，并且使用 `return` 语句返回。

- 如果箭头函数直接返回一个对象，则需要在对象使用**圆括号**将其括起来，否则会报错；或者在对象外使用**大括号**并且 `return` 语句。

	```javascript
	let getTempItem = id => ({ id: id, name: "Temp" });
	
	let getTempItem = id => {
		return {
			id: id,
			name: "Temp"
		}
	};
	```
	
- 函数体内的 `this` 对象，就是**定义时**所在的对象，而**不是使用时**所在的对象。

- **不可以**当作**构造函数**，也就是说，不可以使用 `new` 命令，否则会抛出一个错误。

- **不可以**使用 `arguments` 对象，该对象在函数体内**不存在**。如果要用，可以用 `rest` 参数代替。

- **不可以**使用 `yield` 命令，因此箭头函数不能用作 `Generator` 函数。

- `arguments`、`super`、`new.target` 这三个变量在箭头函数中是不存在的，而是指向外层函数的变量。

- 由于箭头函数没有自己的 `this`，因此也就无法使用 `call()`、`apply()` 和 `bind()` 改变 `this` 指向。

- 在箭头函数中，`this` 的指向是固定的。原因是因为箭头函数内部没有自己的 `this`，导致内部的 `this` 就是外部代码块的 `this`。
	
### 2、应用

- 简化回调函数

### 3、不适合使用场景

- 定义函数的方法，且该方法内部包括 `this`。

- 需要动态使用 `this`。

## 六、双冒号运算符（提案）

函数绑定运算符是使用并排的两个冒号 `::`，双冒号的左边是一个对象，而右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（`this`），绑定到右边的函数上。

## 七、尾调用优化

### 1、尾调用

某个函数的最后一步是调用另一个函数。

```javascript
function f () {
	return g();
}
```

调用函数时，会在内存中开辟一块内存空间来存储函数信息，比如变量、调用位置之类的，我们可以称之为 “调用记录”，或者称为 “调用帧”；如果函数内部又调用其它函数，类似的也会有自己的 “调用帧”，以此类推，所有的 “调用帧” 会形成 “调用栈”。

而尾调用是函数最后一步操作，因此不需要外层函数的信息，即不需要保留外层函数的 “调用帧”，而只需要保留内层函数的 “调用帧”，即只保存一条记录，称为 “尾调用优化”。

### 2、尾递归

某个函数的最后一步是调用自身函数，称为尾递归。

柯里化：将多参数的函数改为单参数的形式。

```javascript
function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}

function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

const factorial = currying(tailFactorial, 1);

factorial(5) // 120
```

### 3、严格模式

ES6 规定尾调用递归只在严格模式下生效，正常模式时无效的。

正常模式下，函数内部有两个变量可以跟踪函数调用栈：

- `func.arguments`：返回调用时函数的参数。

- `func.caller`：返回调用当前函数的那个函数。

但是在严格模式下禁用这两个变量。

### 4、尾递归优化的实现

- 为了减少调用栈，可以使用**循环**替代递归。

- 蹦床函数：每一步返回一个函数。

	```javascript
	function trampoline(fun /*, args */) {
		var result = fun.apply(fun, _.rest(arguments));
  		while (_.isFunction(result)) {
  			result = result();
  		}
  		return result;
}
	```

## 八、函数参数的尾逗号

ES7 允许函数的最后一个参数可以有尾逗号。

### [参考链接](http://es6.ruanyifeng.com/#docs/function)




