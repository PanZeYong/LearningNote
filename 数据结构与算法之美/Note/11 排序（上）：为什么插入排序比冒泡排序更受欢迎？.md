# 排序（上）：为什么插入排序比冒泡排序更受欢迎？

### 一、分析排序算法的步骤

#### 1、排序算法的执行效率

- 从时间复杂度的情况分析，分别为最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度；

- 在对比同一阶段时间复杂度算法的性能时，需要考虑时间复杂度的系数、常数和低阶；

- 比较次数和交换（移动次数）

### 2、排序算法的内存消耗

可以通过空间复杂度来衡量排序算法的内存消耗。对于排序算法的衡量，这里引入一个新的概念：**原地排序**，即空间复杂度是 O(1) 的排序算法。

### 3、排序算法的稳定性

稳定性指标是指在待排序的序列存在相同值的元素，经过排序之后，它们之间的顺序未发生改变。那么这里就可以得出两种算法：稳定的排序算法和不稳定的排序算法。

- 稳定的排序算法：相同值的元素经过排序之后，它们前后顺序未发生改变。

- 不稳定的排序算法：相同值的元素经过排序之后，它们前后顺序发生改变。

### 二、有序度、逆序度和满有序度

#### 有序度

数组中具有有序关系的元素对个数，在数学中可以这样表示：

```
有序元素对：a[i] <= a[j], 如果 i < j。
```

#### 逆序度

定义与有序度相反，在数学中可以这样表示：

```
逆序元素对：a[i] > a[j], 如果 i < j。
```

#### 满有序度

数组中的元素完全有序，可以用以下公式计算其元素对个数：

```
n * (n - 1) / 2
```

#### 公式

```
满有序度 = 有序度 + 逆序度
```
### 三、排序算法

#### 1、冒泡排序（Bubble Sort）

##### 定义

冒泡排序整个处理过程可以这么说：将整个待排序的记录分为有序区和无序区，默认有序区是空的，无序区是包含所有元素。假设数组的长度为 n，那么最坏的情况是要经过 n 趟冒泡排序，在每趟冒泡排序的过程中，无序区相邻的两个元素一一进行比较，如果满足一定的大小关系，则交换位置，一趟排序下来，至少有一个元素会移到最右端，进入有序区。

##### 代码实现：

```python
def bubble_sort(array, n):

    for i in range(n):
        is_swap = False
        for j in range(n - i - 1):
            if (array[j] > array[j+1]):
                temp = array[j]
                array[j] = array[j+1]
                array[j+1] = temp
                is_swap = True

        if is_swap == False:
            break

    return array 
```

##### 分析

冒泡排序是原地排序算法、稳定的排序算法，其时间复杂度如下：

最好情况下时间复杂度： $T(n) = O(n)$。

平均情况下时间复杂度： $T(n) = O(n^2)$。

最坏情况下时间复杂度： $T(n) = O(n^2)$。

#### 2、直接插入排序（Straight Insertion Sort）

##### 定义

直接插入排序：将整个待排序记录分为有序区和无序区，第一个元素默人在有序区，排序从第二个元素开始一趟排序，将第二个元素存放到变量 value 中，之后开始比较，即 value 如果大于第一个元素，则将第一个元素存放到第二个元素位置，如果此时在 value 前面还有元素未比较，则继续比较；否则将 value 存放到相应的位置，然后开始下一趟排序，依此类推。

下面通过一个例子来说明直接插入排序的过程，如下图：

![](/Users/Pan/Program/LearningNote/数据结构与算法之美/Note/images/straight_insertion_sort.png)

##### 代码实现：

```python
def straight_insertion_sort(array, n):
    if n <= 1:
        return

    for i in range(1, n):
        key = array[i]
        j = i - 1
        
        while j >= 0 and array[j] > key:
            array[j + 1] = array[j]
            j -= 1

        array[j + 1] = key

    return array
```

##### 分析

直接插入排序是原地排序算法、稳定的排序算法，其时间复杂度如下：

最好情况下时间复杂度： $T(n) = O(n)$。

平均情况下时间复杂度： $T(n) = O(n^2)$。

最坏情况下时间复杂度： $T(n) = O(n^2)$。

#### 3、直接选择排序（Straight Selection Sort）

##### 定义

直接选择排序：将整个待排序记录分为有序区和无序区，默认有序区为空，对于每一趟排序，从无序区选择最小的关键字值放到有序区，依次类推，从而使待排序记录在有序区变成有序的记录，从小到大排序或者从大到小排序的序列。

##### 代码实现

```python
def straight_selection_sort(array, n):
    if n <= 1:
        return array

    for i in range(n - 1):
        min = i
        for j in range(i + 1, n):
            if array[min] > array[j]:
                min = j

        if min != i:
            temp = array[i]
            array[i] = array[min]
            array[min] = temp

    return array
```

##### 分析

直接选择排序是原地排序算法、不稳定的排序算法，其时间复杂度如下：

最好情况下时间复杂度： $T(n) = O(n^2)$。

平均情况下时间复杂度： $T(n) = O(n^2)$。

最坏情况下时间复杂度： $T(n) = O(n^2)$。




