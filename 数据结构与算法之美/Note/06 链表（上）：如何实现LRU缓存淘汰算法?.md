
# 06 链表（上）：如何实现LRU缓存淘汰算法?

### 1、缓存淘汰算法策略（实现三种策略的算法）

- 先进先出策略 FIFO（First In，First Out）：如果一个数据最先进入缓存中，那么当缓存满的时候，该数据应该最早被淘汰掉。

- 最少使用策略 LFU（Least Frequently Used）：基于访问次数。如果一个数据在最近一段时间内使用的次数很少，那么在未来一段时间内被访问的可能性也很小；也就是说，当缓存满的时候，该数据应该最早被淘汰掉。

- 最近最少使用策略 LRU（Least Recently Used）：基于访问时间。如果一个数据在最近一段时间内没有被访问，那么在未来一段时间内被访问的可能性也很小；也就是说，当缓存满的时候，该数据应该最早被淘汰掉。

### 2、单链表
单链表是最简单的一种链式结构。表中每个数据元素除了要存储本身的信息外，还需要存储其后继元素的地址，这两部分信息组成数据元素的存储映像，称为结点。每个数据元素结点包含两部分：数据域和指针域，即存储数据元素信息的称为数据域，存储其后继结点地址的域称为指针域。

单链表有两个比较特殊的结点：头结点和尾结点。头结点用来记录链表的基地址，数据域可以不存储任何信息，指针域存储第一个结点的地址；而尾结点是链表最后一个数据元素，数据域存储本身信息，但是指针域不再是指向下一个结点，而是指向空地址 NULL。

![](/Users/Pan/Program/数据结构与算法之美/Note/images/linked_list.jpg)

### 3、循环链表
循环链表是一种特殊的单链表，它与单链表的区别在于：单链表尾节点的指针域指向的是空指针，而循环链表尾节点的指针域指向头结点，形成一个环，由于是单向的，也可以成为单循环链表。

![](/Users/Pan/Program/数据结构与算法之美/Note/images/loop_linked_list.jpg)

### 4、双链表

单链表只有一个方向，每个结点的指针域指向下一个结点，若要查找结点的前驱节结点，只能遍历整个链表，时间复杂度为 O(n)；而对于双链表，顾名思义，是双向的，即结点有前驱结点和后继结点，若要查找结点的前驱结点，可以通过结点的 prev 指针快速找到，时间复杂度为 O(1)，这是采用空间换时间的策略。

![](/Users/Pan/Program/数据结构与算法之美/Note/images/double_linked_list.jpg)

### 5、双向循环链表
在双链表的基础上，尾结点的指针域指向头结点，形成一个环，称之为双向循环链表。

![](/Users/Pan/Program/数据结构与算法之美/Note/images/double_loop_linked_list.jpg)

### 6、线性表实现方法比较

线性表的存储结构有两种：顺序存储和链式存储，前者称为顺序表（数组），后者称为链表。它们有如下特点：

- 实现方式不同
	- 顺序表实现方式比较简单，比如各种高级语言的数组类型；
	
	- 链表是基于指针实现的，相对比较复杂。

- 存储空间的占用和分配不同

	- 顺序表的存储空间是静态分配的，在使用之前必须指定其大小；

	- 链表的存储空间是动态分配的，在程序运行时根据需要进行分配。
- 线性表运算的实现方式不同

	- 顺序表具有随机访问的特点；而链表访问指定元素时只能从头开始进行遍历；

	- 顺序表进行插入、删除操作时，需要移动表中的元素，效率比较低；而链表不需要移动元素。

### 7、问题

- 如何基于链表实现 LRU 缓存淘汰算法？

- 如何利用数组实现 LRU 缓存淘汰策略呢？

- 如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？

- CPU 缓存机制

- 双链表的增删改查（done）