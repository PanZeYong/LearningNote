09 | 队列：队列在线程池等有限资源池中的应用

# 一、队列的类型定义

队列是一种只允许在表的一端插入，在另一端删除的存取受限的线性表。允许插入的一端称为**队尾**，允许删除的一端称为**队头**。从定义中可以看出，队列就像排队一样，先入队的元素先出队，后入队的元素后出队。所以，队列是一种**先进先出**(First In First Out，FIFO)的线性表。

![](/Users/Pan/Program/LearningNote/数据结构与算法之美/Note/images/queue.png)

# 二、队列的实现

队列与栈类似，都是操作受限的线性表，而线性表有两种实现方式：顺序表和链表。与之对应的是，队列的实现方式有顺序对列和链式队列。

### 1、顺序队列

利用顺序存储结构实现的队列称之为顺序队列，一般是通过数组来实现。那么在实现过程中，除了开辟容纳数组元素的空间外，还需要声明两个指针，即头指针 head 和尾指针 tail，分别指向队头和队尾。

在用数组实现队列时，判断队列满或空的条件如下：

- 队空：head == tail；

- 队满：tail == n （n 表示数组的长度）；

当 tail 指针移动到数组最右边时，此时队满，再添加元素的话是无法入队的；而此时删除元素时，head 指针往右边移动，这时就出现数组不连续的现象，数组有空间但是无法添加元素，此时的队满是 “假溢出”。那么为了解决这一现象，可以采用**数据搬迁**的方法，即数组后面的元素往前面移动。那么是在入队的时候移动元素还是在出队的时候移动元素呢？如果是在出队的时候移动元素，即每次出队操作后都得移动元素，这样的操作很耗性能；反之，在入队的时候移动元素，即在入队前先判断队列是否已满并且 head 指针是否指向初始位置，如果 `tail == n && head != 0` 时，则执行数据搬迁操作，然后再入队；否则，直接入队。

入队出队示意图：

![](/Users/Pan/Program/LearningNote/数据结构与算法之美/Note/images/queue_enter_exit.png)

数据搬迁示意图：

![](/Users/Pan/Program/LearningNote/数据结构与算法之美/Note/images/queue_data_move.png)

为了解决 “假溢出” 这种现象，除了数据搬迁外，还有一种比较高效的方法，即将队列的数据区看出头尾相接的循环结构，我们称之为**循环队列**。

在实现循环队列的过程中，难点是如何判断队空队满及如何区分它们？以下给出三种方法：

- 牺牲一个存储空间，即 (tail + 1) % MAXSIZE = head;

- 引入一个标志变量区分队列是否为空；

- 使用计数器。

### 2、链式队列

利用链式存储结构实现的队列称之为链式队列，一般可以通过单链表来实现。同顺序队列一样，实现链式队列也需要设置头指针和尾指针，分别指向队头和队尾。

### 3、阻塞队列（BlockingQueue）

阻塞队列是在队列的基础添加两个附加操作，两个附加操作分别是：当队列为空时，获取元素的线程会等待到队列有数据；当队列已满时，添加元素的线程会等待到队列有空闲空间再插入数据。阻塞队列常用于 “生产者-消费模型” 场景，生产者负责往队列添加元素，而消费者负责从队列获取元素。

### 4、并发队列

在多线程的场景下，会出现多个线程操作一个队列，那么这时就会存在线程安全的问题。那么如何解决呢？有一种队列可以解决线程安全问题，即**并发队列**。那么如何实现并发队列呢？方法如下：

- 在入队出队时**加锁**；

- 基于数组的循环队列，利用 CAS 原子操作实现无锁队列。

# 三、队列的应用

- 分布式中消息队列

- 操作系统资源调度分配

- 线程池

- 数据库连接池

# 四、问题

- 阻塞队列、并发队列实现

- 无锁队列实现

- CAS 原子操作


